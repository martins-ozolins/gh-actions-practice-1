name: Deploy website
on:
  push:
    branches:
      - main
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        # Check out the repository so we can run tests and build
        uses: actions/checkout@v3

      # Cache node_modules
      - name: Cache dependencies
        uses: actions/cache@v4 # Use GitHub Action to cache folders and files
        with:
          path: ~/.npm # The folder we want to cache (npm stores downloaded packages here)

          # Cache is keyed by a hash - each cache we create is stored with a unique key
          # In this case, our key is based on the contents of package-lock.json
          # hashFiles(file) => a function that reads the contents of the specified file(s) and creates a hash of those contents.
          # Once the file changes (e.g., new dependencies added), the hash changes → a new cache is created.
          key: deps-node-modules-${{hashFiles('**/package-lock.json')}}

      - name: Install dependencies
        # Even after restoring the cache, we still run `npm ci`:
        # 1. The cache (~/.npm) only stores the downloaded package files, not node_modules.
        # 2. `npm ci` installs dependencies into node_modules for this workflow.
        # 3. Ensures exact versions from package-lock.json and rebuilds any native packages.
        # The cache just speeds up installs by avoiding network downloads.
        run: npm ci

      - name: Lint code
        # Run the linter to check code formatting and style issues
        run: npm run lint

      - name: Test code
        # Run the test suite to verify that the code works correctly
        run: npm run test

  build:
    needs: test
    runs-on: ubuntu-latest

    outputs:
      # Specify a job-level output that other jobs can access
      # This is NOT the same as an artifact; this is a "metadata" output
      # It references the output of a step (here the step with id "publish")
      script-file: ${{steps.publish.outputs.js-file }}

    steps:
      - name: Get code
        uses: actions/checkout@v3

      # Cache node_modules
      - name: Cache dependencies
        uses: actions/cache@v4 # Use GitHub Action to cache folders and files
        with:
          path: ~/.npm # The folder we want to cache (npm stores downloaded packages here)

          # Cache is keyed by a hash - each cache we create is stored with a unique key
          # In this case, our key is based on the contents of package-lock.json
          # hashFiles(file) => a function that reads the contents of the specified file(s) and creates a hash of those contents.
          # Once the file changes (e.g., new dependencies added), the hash changes → a new cache is created.
          key: deps-node-modules-${{hashFiles('**/package-lock.json')}}

      - name: Install dependencies
        # Even after restoring the cache, we still run `npm ci`:
        # 1. The cache (~/.npm) only stores the downloaded package files, not node_modules.
        # 2. `npm ci` installs dependencies into node_modules for this workflow.
        # 3. Ensures exact versions from package-lock.json and rebuilds any native packages.
        # The cache just speeds up installs by avoiding network downloads.
        run: npm ci

      - name: Build website
        run: npm run build

        # Create build artifacts (files or folders) using GitHub Actions
        # These artifacts can be used in other jobs later
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist
          # Use the same name in the deploy job to download these files
          # We can specify multiple paths using the pipe symbol:
          # path: |
          #   dist
          #   package.json

      - name: Publish JS filename
        id: publish
        # The `id` gives this step a reference name, so other steps or job outputs can access its outputs
        # Here we find the JS file in dist/assets and write it as a step output
        run: find dist/assets/*.js -type f -execdir echo 'js-file={}' >> $GITHUB_OUTPUT ';'
        # $GITHUB_OUTPUT is a special file that allows a step to define outputs
        # Each line should be of the form name=value
        # In this case, "js-file" will be available as steps.publish.outputs.js-file

  deploy:
    needs: build # This job waits for the "build" job to finish
    runs-on: ubuntu-latest
    steps:
      - name: Get build artifacts
        # Download artifacts created in the build job
        # Use the same name as given when uploading artifacts ("dist-files")
        uses: actions/download-artifact@v4
        with:
          name: dist-files

        # All files inside /dist are now available in the runner
        # Note: the files are extracted into the runner's working folder, not inside a /dist folder (no longer /dist folder)

      - name: Output contents
        # List the files to verify that the artifacts were downloaded correctly
        run: ls

      - name: Output filename
        # Access the output from the build job
        # `needs.build.outputs.script-file` references the job-level output we defined earlier
        # This allows passing data (like a filename) from one job to another
        run: echo "${{ needs.build.outputs.script-file }}"

      - name: Deploy
        run: echo "Deploying..."
